%   CLASS GPS_Time
% =========================================================================
%
% DESCRIPTION
%   Class to manage times and dates in various format (GPS / UTC/ ...)
%
% EXAMPLE
%   settings = GPS_Time();
%
% CONSTRUCTOR SYNTAX
%   t = GPS_Time(matlab_time, <[]>, <is_gps = 1>, <0>);
%   t = GPS_Time(uint32(unix_time), fraction_of_second, <is_gps = 1>, <1>);
%   t = GPS_Time(time_matlab_reference, time_difference, <is_gps = 1>, <2>);
%
% FOR A LIST OF CONSTANTs and METHODS use doc GPS_Time
%
% COMMENTS
% The class stores arrays of time, not just a single element,
% it has been designed this way because MATLAB works best on arrays
%
% This is probably an overcomplicated class, but storing times in multiple
% ways allows speed improvements.

%--- * --. --- --. .--. ... * ---------------------------------------------
%               ___ ___ ___
%     __ _ ___ / __| _ | __|
%    / _` / _ \ (_ |  _|__ \
%    \__, \___/\___|_| |___/
%    |___/                    v 1.0RC1
%
%--------------------------------------------------------------------------
%  Copyright (C) 2021 Geomatics Research & Development srl (GReD)
%  Written by:        Andrea Gatti ...
%  Contributors:      Andrea Gatti, Giulio Tagliaferro ...
%  A list of all the historical goGPS contributors is in CREDITS.nfo
%--------------------------------------------------------------------------
%
%   This program is free software: you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation, either version 3 of the License, or
%   (at your option) any later version.
%
%   This program is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.
%
%   You should have received a copy of the GNU General Public License
%   along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------------------------------------
% 01100111 01101111 01000111 01010000 01010011
%--------------------------------------------------------------------------

classdef GPS_Time < Exportable & handle
    
    properties (Constant, GetAccess = public)
        DAYS_IN_WEEK = uint32(7);               % Number of days in a week
        SEC_IN_DAY  = uint32(86400);            % Number of seconds in a day
        SEC_IN_HALF_WEEK = uint32(302400);      % Number of seconds in a half a week
        SEC_IN_WEEK = uint32(604800);           % Number of seconds in a half a week
        UNIX_GPS_SEC_DIFF = uint32(315964800);  % Seconds of difference between UNIX time and GPS time
        
        DEFAULT_DATE_FORMAT = 'yyyy/mm/dd HH:MM:SS'; % String representing the format of visualization of the time
        
        % Epochs in (UTC time), matlab format when a leap second happened
        LEAP_DATES_UTC =   ([ 723728; 724093; 724458; 725189; 726103;
            726834; 727199; 727746; 728111; 728476;
            729025; 729572; 730121; 732678; 733774;
            735051; 736146; 736696]);
        
        % datenum ignores cycle slips -> in UTC leap seconds happen "before"
        LEAP_DATES_GPS =   ... %LEAP_DATES_UTC + (1:(length(LEAP_DATES_UTC)))'/86400;
            ([ 723728.000011574; 724093.000023148; 724458.000034722; 725189.000046296; 726103.00005787; ...
            726834.000069444; 727199.000081019; 727746.000092593; 728111.000104167; 728476.000115741; ...
            729025.000127315; 729572.000138889; 730121.000150463; 732678.000162037; 733774.000173611; ...
            735051.000185185; 736146.000196759; 736696.000208333; ]);
        
        %       Generated by:
        %                      datenum( '1981/07/01'; '1982/07/01'; '1983/07/01'; '1985/07/01'; '1988/01/01'; ...
        %                               '1990/01/01'; '1991/01/01'; '1992/07/01'; '1993/07/01'; '1994/07/01'; ...
        %                               '1996/01/01'; '1997/07/01'; '1999/01/01'; '2006/01/01'; '2009/01/01'; ...
        %                               '2012/07/01'; '2015/07/01'; '2017/01/01'})
        
        GPS_ZERO = 723186;              % datenum('Jan 6, 1980')
        GPS_BDS_WEEK0 = 1356;            % GPS week number on 1st January 2006 (start of BeiDou time)
        UNIX_ZERO = 719529;             % datenum('Jan 1, 1970')
    end
    
    properties (Constant, GetAccess = private)
        MAT_TIME = 0;       % time_type value for times stored in matalb format: (double array) time in days since January 1, 0000 (matlab datenum fomat), precision up to the 0.1 milliseconds
        UNIX_TIME = 1;      % time_type value for times stored in unix format: (uint32 array) time in seconds since January 1, 1970 (UNIX standard) + (double array) fraction of seconds
        REF_TIME = 2;       % time_type value for times stored in time_ref: (double) origin of the "time system" expressed in datenum format + (double array) difference in seconds w.r.t. time_ref
    end
    
    properties (SetAccess = private, GetAccess = public)        
        time_type = 0;      % flag depending on its value different representation of time are possible
        
        % time_type == 0 MATLAB_TIME DEFAULT it supports up to ~0.1 ms precision
        
        mat_time            % (double array) time in days since January 1, 0000 (matlab datenum fomat), precision up to the 0.1 milliseconds
        
        % time_type == 1 UNIX_TIME it supports ps precision
        
        unix_time           % (uint32 array) time in seconds since January 1, 1970 (UNIX standard)
        unix_time_f         % (double array) fraction of seconds
        
        % time_type == 2 REFERENCED_TIME it supports ps precision
        
        time_ref            % (double) origin of the "time system" expressed in datenum format
        time_diff           % (double array) difference in seconds w.r.t. time_ref
        
        is_gps = true;       % define whether is gps time or UTC
        
        
        date_format = GPS_Time.DEFAULT_DATE_FORMAT;
        leap_seconds = 999;
    end
    
    % Function to simulate polymorphism
    methods (Access = 'public')
        function this = GPS_Time_str(this, string_time, is_gps)
            % Private constructor - simulate polymorphism - GPS_Time_str(string_time, is_gps)
            %
            % SYNTAX
            %   this = GPS_Time_str(this, string_time, is_gps)
            if (nargin == 3)
                if isempty(is_gps)
                    is_gps = true;
                end
                this.is_gps = is_gps;
            else
               is_gps = true;
            end
            % str = regexprep(string_time(:)','[^0-9.]',' '); % sanityse string -> most of the time is not needed (consider to put it externally)
            if isempty(strtrim(string_time(:)))
                % no time = > empty GPS_Time
            else
                str = regexprep(string_time(:)', '[\/|\:|\-]', ' ');
                date = sscanf(str,'%f%f%f%f%f%f')';
                                
                if numel(date) <= 3
                    % fallback to datevec
                    date_format = 'yyyy mm dd';
                    date = datevec(string_time, date_format);
                    if isempty(regexp(str(3),'[0-9]', 'once')) % 2 digits year
                        date(date(:,1) < 80, 1) = date(date(:,1) < 80, 1) + 2000;
                        date(date(:,1) < 100, 1) = date(date(:,1) < 100, 1) + 1900;
                    end
                    if (date(1) < 1980) || (date(1) > 2070)
                        % fallback to datenum
                        this.GPS_Time_mat(datenummx(date), is_gps);
                    else
                        this.GPS_Time_6col(date, is_gps);
                    end
                else
                    date_format = 'yyyy mm dd HH MM SS';
                    try
                        tmp = reshape(date, 6, numel(date) / 6)';
                        date = tmp;
                    catch
                        date = datevec(datenum(string_time));
                    end
                    if isempty(regexp(str(3),'[0-9]', 'once')) % 2 digits year
                        date(date(:,1) < 80, 1) = date(date(:,1) < 80, 1) + 2000;
                        date(date(:,1) < 100, 1) = date(date(:,1) < 100, 1) + 1900;
                        this.GPS_Time_6col(date, is_gps);
                    else
                        if (date(1) < 1980) || (date(1) > 2070)
                            % fallback to datenum
                            this.GPS_Time_mat(datenummx(date), is_gps);
                        else
                            this.GPS_Time_6col(date, is_gps);
                        end
                    end
                end
            end
        end
        
        function this = GPS_Time_mat(this, matlab_time, is_gps)
            % Private constructor - simulate polymorphism - GPS_Time_mat(matlab_time, is_gps)
            %
            % SINTAX
            %   this = GPS_Time_mat(this, matlab_time, is_gps)
            this.time_type = 0;
            this.mat_time = matlab_time;
            if (nargin == 3)
                if isempty(is_gps)
                    is_gps = true;
                end
                this.is_gps = is_gps;
            end
        end
        
        function this = GPS_Time_unix(this, unix_time, fraction_of_second, is_gps)
            % Private constructor - simulate polymorphism - GPS_Time_unix(uint32(unix_time), fraction_of_second, is_gps)
            %
            % SYNTAX
            %   this = GPS_Time_unix(this, unix_time, fraction_of_second, is_gps)
            this.time_type = 1;
            this.unix_time = uint32(unix_time);
            this.unix_time_f = fraction_of_second;
            if (nargin == 4)
                if isempty(is_gps)
                    is_gps = true;
                end
                this.is_gps = is_gps;
            end
        end
        
        function this = GPS_Time_6col(this, date, is_gps)
            % Private constructor - simulate polymorphism - GPS_Time_6col(data_6col, is_gps)
            %
            % SYNTAX
            %   this = GPS_Time_6col(this, date, is_gps)
            %
            % check date format 2/4 digits
            
            %date(date(:,1) < 70,1) = date(date(:,1) < 70,1) + 2000;
            %date(date(:,1) > 2070,1) = date(date(:,1) > 2070,1) - 100;
            this.time_type = 1;
            if (nargin == 3)
                if isempty(is_gps)
                    is_gps = true;
                end
            elseif (nargin == 2)
                is_gps = true;
            end
            
            unx_ref = 719529; % this.UNIX_ZERO
            
            % number of days since the beginning of Unix time
            % deltat   = (datenum([date(:,1), date(:,2), date(:,3)]) - unx_ref);
            % hack: datenummmx is faster cause it does not check argins
            unix_time   = uint32((datenummx(date(:,1:3)) - unx_ref)) * 86400; %#ok<PROPLC>
            
            if (size(date, 2) == 6)
                % I want to keep precision (let's use Unix time)
                s = floor(date(:,6));
                unix_time = unix_time + uint32(date(:,4)) * 3600 + uint32(date(:,5)) * 60 + uint32(s);  %#ok<PROPLC>
                fraction_of_second = round((date(:,6) - s)*1e14)/1e14;
            else
                fraction_of_second = 0;
            end
            
            this.is_gps = is_gps;
            this.unix_time = unix_time; %#ok<PROPLC>
            this.unix_time_f = fraction_of_second;
        end
        
        function this = GPS_Time_Week_Dow(this, week, dow)
            % Private constructor - simulate polymorphism - GPS_Time_Week_Dow(week, dow)
            %
            % SYNTAX
            %   this = GPS_Time_Week_Dow(this, week, dow)
            this.unix_time = uint32((this.GPS_ZERO - this.UNIX_ZERO)*86400 + week*86400*7 + dow*86400);
            this.unix_time_f = zeros(size(this.unix_time));
            this.time_type = 1;
        end
        
        function this = GPS_Time_ref(this, time_matlab_reference, time_difference, is_gps)
            % Private constructor - simulate polymorphism - GPS_Time_mat(time_matlab_reference, time_difference, is_gps)
            %
            % SYNTAX
            %   this = GPS_Time_ref(this, time_matlab_reference, time_difference, is_gps)
            this.time_type = 2;
            this.time_ref = time_matlab_reference;
            this.time_diff = time_difference(:);
            if (nargin == 4)
                if isempty(is_gps)
                    is_gps = true;
                end
                this.is_gps = is_gps;
            end
        end
        
        function this = appendStrTime(this, string_time, is_gps)
            % Append elements - appendMatTime(matlab_time, is_gps)
            %
            % SYNTAX
            %   this = appendStrTime(this, string_time, is_gps)
            if (nargin == 3)
                if isempty(is_gps)
                    is_gps = this.is_gps;
                end
            elseif (nargin == 2)
                is_gps = this.is_gps;
            end
            date = sscanf(string_time,'%f%f%f%f%f%f')';
            
            if numel(date) <= 3
                % fallback to datevec
                date_format = 'yyyy mm dd';
                date = datevec(string_time, date_format);
                if isempty(regexp(str(3),'[0-9]', 'once')) % 2 digits year
                    date(date(:,1) < 80, 1) = date(date(:,1) < 80, 1) + 2000;
                    date(date(:,1) < 100, 1) = date(date(:,1) < 100, 1) + 1900;
                end
                if (date(1) < 1980) || (date(1) > 2070)
                    % fallback to datenum
                    this.appendMatTime(datenummx(date), is_gps);
                else
                    this.append6ColDate(date, is_gps);
                end
            else
                date_format = 'yyyy mm dd HH MM SS';
                try
                    tmp = reshape(date, 6, numel(date) / 6)';
                    date = tmp;
                catch ex
                    date = datevec(string_time, date_format);
                end
                if isempty(regexp(string_time(3),'[0-9]', 'once')) % 2 digits year
                    date(date(:,1) < 80, 1) = date(date(:,1) < 80, 1) + 2000;
                    date(date(:,1) < 100, 1) = date(date(:,1) < 100, 1) + 1900;
                    this.append6ColDate(date, is_gps);
                else
                    if (date(1) < 1980) || (date(1) > 2070)
                        % fallback to datenum
                        this.appendMatTime(datenummx(date), is_gps);
                    else
                        this.append6ColDate(date, is_gps);
                    end
                end
            end
        end
        
        function this = appendMatTime(this, matlab_time, is_gps)
            % Append elements - appendMatTime(matlab_time, is_gps)
            % SYNTAX
            %   this = appendMatTime(this, matlab_time, is_gps)
            if (nargin == 3)
                if isempty(is_gps)
                    is_gps = this.is_gps;
                end
            elseif (nargin == 2)
                is_gps = this.is_gps;
            end
            this.append(GPS_Time(matlab_time, [], is_gps, 0));
        end
        
        function this = appendUnixTime(this, unix_time, fraction_of_second, is_gps)
            % Append elements -  appendUnixTime(uint32(unix_time), fraction_of_second, is_gps)
            %
            % SYNTAX
            %   this = appendUnixTime(this, unix_time, fraction_of_second, is_gps)
            if (nargin == 4)
                if isempty(is_gps)
                    is_gps = this.is_gps;
                end
            elseif (nargin == 3)
                is_gps = this.is_gps;
            end
            this.append(GPS_Time(unix_time, fraction_of_second, is_gps, 1));
        end
        
        function this = append6ColDate(this, date, is_gps)
            % Append elements -  this.append6ColDate(date, is_gps)
            %
            % SYNTAX
            %   this = append6ColDate(this, date, is_gps)
            
            if (nargin == 3)
                if isempty(is_gps)
                    is_gps = this.is_gps;
                end
            elseif (nargin == 2)
                is_gps = this.is_gps;
            end
            
            unx_ref = 719529; % this.UNIX_ZERO
            
            % number of days since the beginning of Unix time
            % deltat   = (datenum([date(:,1), date(:,2), date(:,3)]) - unx_ref);
            % hack: datenummmx is faster cause it does not check argins
            unix_time   = uint32((datenummx(date(:,1:3)) - unx_ref) * 86400); %#ok<PROPLC>
            
            if (size(date, 2) == 6)
                % I want to keep precision (let's use Unix time)
                this.toUnixTime();
                s = floor(date(:,6));
                unix_time = unix_time + uint32(date(:,4)) * 3600 + uint32(date(:,5)) * 60 + uint32(s);  %#ok<PROPLC>
                fraction_of_second = round((date(:,6) - s)*1e14)/1e14;
            else
                fraction_of_second = 0;
            end
            
            this.append(GPS_Time(unix_time, fraction_of_second, is_gps, 1)); %#ok<PROPLC>
        end
        
        function this = appendRefTime(this, time_matlab_reference, time_difference, is_gps)
            % Append elements - appendRefTime(time_matlab_reference, time_difference, is_gps)
            %
            % SYNTAX
            %   this = appendRefTime(this, time_matlab_reference, time_difference, is_gps)
            if (nargin == 4)
                if isempty(is_gps)
                    is_gps = this.is_gps;
                end
            elseif (nargin == 3)
                is_gps = this.is_gps;
            end
            
            this.append(GPS_Time(time_matlab_reference, time_difference, is_gps, 2));
        end
    end
    
    methods
        function this = GPS_Time( arg1, arg2, arg3, arg4)
            % Constructor
            %
            % SYNTAX
            %   t = GPS_Time(matlab_time, <[]>, <is_gps = 1>, <0>);
            %   t = GPS_Time(uint32(unix_time), fraction_of_second, <is_gps = 1>, <1>);
            %   t = GPS_Time(time_matlab_reference, time_difference, <is_gps = 1>, <2>);
            
            switch nargin
                % With one parameter I assume to read GPS time in matlab format (string or number)
                % one value (in seconds) with milliseconds precision since 1 Jan 0000
                case 1
                    if isa(arg1,'char')
                        % string time (matlab time)
                        this.GPS_Time_str(arg1);
                    else
                        if size(arg1,2) == 1
                            % matlab time
                            this.GPS_Time_mat(arg1);
                        else
                            this.GPS_Time_6col(arg1);
                        end
                    end
                    % With two parameters it can be a unix o ref time format
                case 2
                    if isa(arg1,'uint32')
                        % UNIX time
                        this.GPS_Time_unix(arg1, arg2);
                    else
                        % Ref Time
                        this.GPS_Time_ref(arg1, arg2);
                    end
                    % With three parameters the thirsd is a flag (is_gps)
                case 3
                    if isempty(arg2) && ~isa(arg1,'uint32')
                        if isa(arg1,'char')
                            % string time (matlab time)
                            this.GPS_Time_str(arg1, arg3);
                        else
                            if size(arg1,2) == 1
                                % matlab time
                                this.GPS_Time_mat(arg1, arg3);
                            else
                                this.GPS_Time_6col(arg1, arg3);
                            end
                        end
                    else
                        if isa(arg1,'uint32')
                            % UNIX time
                            this.GPS_Time_unix(arg1, arg2, arg3);
                        else
                            % Ref Time
                            this.GPS_Time_ref(arg1, arg2, arg3);
                        end
                    end
                case 4
                    switch arg4
                        case 0 % GPS_Time.MAT_TIME
                            this.GPS_Time_mat(arg1, arg3);
                        case 1 % GPS_Time.UNIX_TIME
                            this.GPS_Time_unix(arg1, arg2, arg3);
                        case 2 % GPS_Time.REF_TIME
                            this.GPS_Time_ref(arg1, arg2, arg3);
                        case 3 % GPS_Time_Week_Dow (to unix time)
                            this.GPS_Time_Week_Dow(arg1, arg2);
                        otherwise
                            Logger.getInstance.addError('Unrecognized time format!!!');
                    end
            end
            %this.computeLeapSeconds();
        end
        
        function addEpoch(this, arg1, arg2, arg3, arg4)
            % Add epochs to the object as matlab/unix/ref time
            %
            % SYNTAX
            %   t = t.appendEpoch(matlab_time, <[]>, <is_gps = 1>, <0>);
            %   t = t.appendEpoch(uint32(unix_time), fraction_of_second, <is_gps = 1>, <1>);
            %   t = t.appendEpoch(time_matlab_reference, time_difference, <is_gps = 1>, <2>);
            
            switch nargin
                % With one parameter I assume to read GPS time in matlab format
                % one value (in seconds) with milliseconds precision since 1 Jan 0000
                case 2
                    if isa(arg1,'char')
                        % string time (matlab time)
                        this.appendStrTime(arg1);
                    else
                        % matlab time
                        this.appendMatTime(arg1);
                    end
                    
                    % With two parameters it can be a unix o ref time format
                case 3
                    if isa(uint32(arg1),'uint32')
                        % UNIX time
                        this.appendUnixTime(arg1, arg2);
                    else
                        % Ref Time
                        this.appendRefTime(arg1, arg2);
                    end
                    % With three parameters the thirsd is a flag (is_gps)
                case 4
                    if isempty(arg2)
                        if isa(arg1,'char')
                            % string time (matlab time)
                            this.appendStrTime(arg1, arg3);
                        else
                            % matlab time
                            this.appendMatTime(arg1, arg3);
                        end
                    else
                        if isa(uint32(arg1),'uint32')
                            % UNIX time
                            this.appendUnixTime(arg1, arg2, arg3);
                        else
                            % Ref Time
                            this.appendRefTime(arg1, arg2, arg3);
                        end
                    end
                case 5
                    switch arg4
                        case 0 % GPS_Time.MAT_TIME
                            this.appendMatTime(arg1, arg3);
                        case 1 % GPS_Time.UNIX_TIME
                            this.appendUnixTime(arg1, arg2, arg3);
                        case 2 % GPS_Time.REF_TIME
                            this.appendRefTime(arg1, arg2, arg3);
                        otherwise
                            Logger.getInstance.addError('Unrecognized time format!!!');
                    end
            end
            %this.computeLeapSeconds();
        end
        
        function import(this, time)
            % Copy from an object of the same type (alias to copyFrom)
            %
            % SYNTAX
            %   this.copyFrom(time)
            this.copyFrom(time)
        end
        
        function copyFrom(this, time)
            % Copy from an object of the same type
            %
            % SYNTAX
            %   this.copyFrom(time)
            this.time_type = time.time_type;
            this.mat_time = time.mat_time;
            this.unix_time = time.unix_time;
            this.unix_time_f = time.unix_time_f;
            this.time_ref = time.time_ref;
            this.time_diff = time.time_diff;
            this.is_gps = time.is_gps;
            this.date_format = time.date_format;
            this.leap_seconds = time.leap_seconds;
        end
        
        function copy = getCopy(gps_list)
            % Get a copy of this
            %
            % SYNTAX
            %   copy = getCopy(gps_list)
            
            n_times = max(size(gps_list));
            copy(n_times) = GPS_Time();
            for t = 1 : n_times
                copy(t).copyFrom(gps_list(t));
            end
        end
        
        function id_sort = sort(this)
            % Return the ids used to sort the time
            % Internally sort the time in ascending way
            %
            % SYNTAX
            %   id_sort = sort(this);
            
            [~, id_sort] = sort(this.getMatlabTime);
            switch this.time_type
                case 0 % I'm in MAT TIME
                    this.mat_time = this.mat_time(id_sort);
                case 1 % I'm in UNIX TIME
                    this.unix_time = this.unix_time(id_sort);
                    this.unix_time_f = this.unix_time_f(id_sort);
                    
                case 2 % I'm in REF TIME
                    this.time_diff = this.time_diff(id_sort);
            end
        end
        
        function this = append(this, time, time_type, is_gps)
            % Append a GPS_Time object into the this
            %
            % SYNTAX
            %   this = append(this, time, time_type, is_gps)
            
            % check if the object is empty
            if isempty(this.time_type)
                this.import(time); % copy time in this
            else
                
                % When not specified the new format is the format of the append
                if (nargin < 3)
                    time_type = this.time_type;
                end
                if (nargin < 4)
                    is_gps = time.is_gps;
                end
                
                % Merge is done in GPS time -> it has no ambiguity
                this.toGps;
                time.toGps;
                
                switch time_type
                    case 0 % I'm in MAT TIME
                        this.toMatlabTime();
                        time.toMatlabTime();
                        
                        this.mat_time = [double(this.mat_time(:)); time.mat_time(:)];
                        
                    case 1 % I'm in UNIX TIME
                        this.toUnixTime();
                        time.toUnixTime();
                        
                        this.unix_time = [uint32(this.unix_time); time.unix_time];
                        this.unix_time_f = [double(this.unix_time_f); time.unix_time_f];
                        
                    case 2 % I'm in REF TIME
                        this.toRefTime();
                        time.toRefTime();
                        
                        % keep the reference of the this
                        this.time_diff = [double(this.time_diff); (time.time_diff + (this.time_ref - time.time_ref) * 86400)];
                end
                
                % Convert into correct format time
                if is_gps
                    this.toGps();
                else
                    this.toUtc();
                end
                
                % Compute leap seconds, if the original data stored them
                if (time.leap_seconds < 999) ||  (this.leap_seconds < 999)
                    this.computeLeapSeconds();
                end
            end
        end
    end
    
    % =========================================================================
    %    CONVERSIONS
    % =========================================================================
    
    methods (Access = 'private')
        function leap_seconds = computeLeapSeconds(this)
            % compute the number of leap seconds to subtract to GPS Time to obtain the UTC time
            %
            % SYNTAX
            %   leap_seconds = computeLeapSeconds(this)
            if this.is_gps
                LEAP_DATES = this.LEAP_DATES_GPS;
            else
                LEAP_DATES = this.LEAP_DATES_UTC;
            end
            
            switch this.time_type
                case 0 % I'm in MAT TIME
                    if (numel(this.mat_time) == 1)
                        leap_seconds = find(this.mat_time > LEAP_DATES, 1, 'last');
                    else
                        leap_seconds = [find(this.mat_time(1) > LEAP_DATES, 1, 'last'); ...
                            find(this.mat_time(end) > LEAP_DATES, 1, 'last') ];
                        if (diff(leap_seconds) == 0) % the same leap_second for the whole period
                            leap_seconds = leap_seconds(1);
                        elseif (diff(leap_seconds) == 1) % there's one leap in the dataset
                            % search for the latest value before the second leap second
                            % max precision of leap dates is 1e-9
                            id_leap = find(round(this.mat_time*1e9) >= round(LEAP_DATES(leap_seconds(2))*1e9),1, 'first') - 1;
                            leap_seconds = [ones(id_leap,1) * leap_seconds(1); ones(numel(this.mat_time) - id_leap,1) * leap_seconds(2)];
                        else % there are multiple leaps in the dataset
                            lp = zeros(size(this.mat_time));
                            lp(1) = leap_seconds(1);
                            lp(end) = leap_seconds(2);
                            for i = 2:length(this.mat_time)-1
                                lp(i) = find(this.mat_time(i) > LEAP_DATES, 1, 'last');
                            end
                            leap_seconds = lp;
                        end
                    end
                case 1 % I'm in UNIX TIME
                    if (numel(this.unix_time) == 1)
                        leap_seconds = find((double(this.unix_time)) / 86400 > (LEAP_DATES - 719529), 1, 'last');
                    else
                        leap_seconds = [ find((double(this.unix_time(1))) / 86400 > (LEAP_DATES - 719529), 1, 'last'); ...
                            find((double(this.unix_time(end))) / 86400 > (LEAP_DATES - 719529), 1, 'last')];
                        if (diff(leap_seconds) == 0) % the same leap_second for the whole period
                            leap_seconds = leap_seconds(1);
                        elseif (diff(leap_seconds) == 1)  % there's one leap in the dataset
                            % search for the latest value before the second leap second
                            id_leap = find((this.unix_time) >= uint32((LEAP_DATES(leap_seconds(2)) - 719529) * 86400),1, 'first') - 1;
                            leap_seconds = [ones(id_leap,1) * leap_seconds(1); ones(numel(this.unix_time) - id_leap,1) * leap_seconds(2)];
                        else % there are multiple leaps in the dataset
                            lp = zeros(size(this.unix_time));
                            lp(1) = leap_seconds(1);
                            lp(length(this.unix_time)) = leap_seconds(2);
                            for i = 2:length(this.unix_time)-1
                                lp(i) = find((double(this.unix_time(i))) / 86400 > (LEAP_DATES - 719529), 1, 'last');
                            end
                            leap_seconds = lp(:);
                        end
                    end
                    
                case 2 % I'm in REF TIME
                    if (numel(this.time_diff) == 1)
                        leap_seconds = find(this.time_ref + this.time_diff  > LEAP_DATES, 1, 'last');
                    else
                        leap_seconds = [find((this.time_ref + this.time_diff(1)) > LEAP_DATES, 1, 'last'); ...
                            find((this.time_ref + this.time_diff(end)) > LEAP_DATES, 1, 'last') ];
                        if (diff(leap_seconds) == 0) % the same leap_second for the whole period
                            leap_seconds = leap_seconds(1);
                        elseif (diff(leap_seconds) == 1) % there's one leap in the dataset
                            % search for the latest value before the second leap second
                            % max precision of leap dates is 1e-9
                            id_leap = find(round(this.time_diff*1e9) >= round((LEAP_DATES(leap_seconds(2)) - this.time_ref)*1e9),1, 'first') - 1;
                            leap_seconds = [ones(id_leap,1) * leap_seconds(1); ones(numel(this.time_diff) - id_leap,1) * leap_seconds(2)];
                        else % there are multiple leaps in the dataset
                            lp = zeros(size(this.time_ref));
                            lp(1) = leap_seconds(1);
                            lp(end) = leap_seconds(2);
                            for i = 2:length(this.time_ref)-1
                                lp(i) = find(this.time_ref + this.time_diff  > LEAP_DATES, 1, 'last');
                            end
                            leap_seconds = lp;
                        end
                    end
                    
            end
            if ~(this.is_gps)
                leap_seconds = -leap_seconds;
            end
            this.leap_seconds = leap_seconds;
        end
    end
    
    methods
        function toMatlabTime(this)
            % Convert the internal structure to Matlab Time, precision up to the 0.1 milliseconds precision
            %
            % SYNTAX
            %   this.toMatlabTime
            switch this.time_type
                case 0 % I'm already in MAT TIME
                    % do nothing
                case 1 % I'm in UNIX TIME
                    this.time_type = 0;
                    % constants in matlab are slower than copied values :-( switching to values
                    % this.mat_time = double(this.unix_time) / this.SEC_IN_DAY + this.UNIX_ZERO + this.unix_time_f;
                    this.mat_time = ((double(this.unix_time) + this.unix_time_f) / 86400 + 719529);
                    this.unix_time = [];
                    this.unix_time_f = [];
                case 2 % I'm in REF TIME
                    this.time_type = 0;
                    this.mat_time = this.time_ref + this.time_diff / 86400;
                    this.time_ref = [];
                    this.time_diff = [];
            end
        end
        
        function toUnixTime(this)
            % Convert the internal structure to Unix Time, precision up to the ps precision
            %
            % SYNTAX
            %   this.toUnixTime
            switch this.time_type
                case 0 % I'm in MAT TIME
                    this.time_type = 1;
                    % constants in matlab are slower than copied values :-( switching to values
                    % time_s = (this.mat_time - this.UNIX_ZERO) * this.SEC_IN_DAY; % convert mat_time in seconds
                    % due to numerical error propagation I can keep only 4 decimal
                    time_s =  (double(this.mat_time) - 719529) * 86400; % convert mat_time in seconds
                    this.unix_time = uint32(fix(round(time_s * 1e4) / 1e4));
                    rounding = 10.^(round(16 - max(0,log10(double(this.mat_time) * 86400 + eps(double(this.mat_time) * 86400))))); % 52 bits of mantissa
                    this.unix_time_f = round((time_s - double(this.unix_time)) .* rounding) ./ rounding;
                    second_correction = - floor(this.unix_time_f);
                    this.unix_time = this.unix_time - uint32(second_correction);
                    this.unix_time_f = this.unix_time_f + second_correction;
                    clear time_s
                    this.mat_time = [];
                case 1 % I'm already in UNIX TIME
                    % do nothing
                    tmp = uint32(round(this.unix_time_f));
                    this.unix_time = this.unix_time + tmp;
                    this.unix_time_f = this.unix_time_f - double(tmp);
                case 2 % I'm in REF TIME
                    this.time_type = 1;
                    % constants in matlab are slower than copied values :-( switching to values
                    % time_s = (this.mat_time - this.UNIX_ZERO) * this.SEC_IN_DAY; % convert mat_time in seconds
                    time_s = (double(this.time_ref) - 719529) * 86400;
                    this.unix_time = uint32(fix(round((time_s + this.time_diff), 4)));
                    rounding = 2.^(round(47 - max(0,log2(time_s + eps(time_s))))); % 52 bits of mantissa -> but I need to consider only 47 bits to keep precision
                    this.unix_time_f = round((time_s - double(this.unix_time)) .* rounding) ./ rounding + double(this.time_diff);
                    second_correction = - floor(this.unix_time_f);
                    this.unix_time = this.unix_time - uint32(second_correction);
                    this.unix_time_f = this.unix_time_f + second_correction;
                    clear time_s
                    this.time_ref = [];
                    this.time_diff = [];
            end
        end
        
        function toRefTime(this)
            % Convert the internal structure to Reference Time, precision up to the ps precision
            %
            % SYNTAX
            %   this.toRefTime
            switch this.time_type
                case 0 % I'm in MAT TIME
                    this.time_type = 2;
                    this.time_ref = fix(this.mat_time(1));
                    % due to numerical error propagation I can keep only 4 decimal digits
                    this.time_diff = round((this.mat_time - this.time_ref) * 86400, 4);
                    this.mat_time = [];
                case 1 % I'm in UNIX TIME
                    this.time_type = 2;
                    % constants in matlab are slower than copied values :-( switching to values
                    % time_d = double(this.unix_time) / this.SEC_IN_DAY + this.UNIX_ZERO;
                    time_d = double(this.unix_time) / 86400 + 719529;
                    this.time_ref = fix(time_d(1));
                    this.time_diff = round((time_d - this.time_ref) * 86400, 4) + this.unix_time_f;
                    this.unix_time = [];
                    this.unix_time_f = [];
                case 2 % I'm already in REF TIME
                    % do nothing
            end
        end
        
        function toUtc(this)
            % Transform the internal allocation in UTF format (corrects for cycle-slip)
            %
            % SYNTAX
            %   this.toUtc
            if this.isempty()
                this.is_gps = false;
            else
                if (this.is_gps == true)
                    if (this.leap_seconds(1) >= 999) || (length(this.leap_seconds) ~= this.length)
                        this.leap_seconds = this.computeLeapSeconds();
                    end
                    this.addSeconds(-this.leap_seconds);
                    this.is_gps = false;
                    this.leap_seconds = -this.leap_seconds;
                end
            end
        end
        
        function toGps(this)
            % Transform the internal allocation in GPS format (corrects for cycle-slips)
            %
            % SYNTAX
            %   this.toGps
            if this.isempty()
                this.is_gps = true;
            else
                if (this.is_gps == false)
                    if (this.leap_seconds >= 999)
                        this.leap_seconds = this.computeLeapSeconds();
                    end
                    this.addSeconds(-this.leap_seconds);
                    this.is_gps = true;
                    this.leap_seconds = -this.leap_seconds;
                end
            end
        end
        
        function leap_seconds = getLeapSeconds(this)
            % get the number of leap seconds to subtract to GPS Time to obtain the UTC time
            %
            % SYNTAX
            %   this.leap_seconds = getLeapSeconds
            if (this.leap_seconds >= 999)
                this.leap_seconds = this.computeLeapSeconds();
            end
            leap_seconds = this.leap_seconds;
        end
    end
    
    % =========================================================================
    %    GETTERS
    % =========================================================================
    
    methods
        function [is_utc] = isUTC(this)
            % Get the memorization type
            %
            % SYNTAX
            %   [is_utc] = isUTC(this)
            is_utc = ~this.is_gps;
        end
        
        function [is_gps] = isGPS(this)
            % Get the memorization type
            %
            % SYNTAX
            %   [is_gps] = isGPS(this)
            is_gps = this.is_gps;
        end
        
        function [len] = numel(this)
            % get number of epochs
            %
            % SYNTAX
            %   [len] = numel(this)
            if isempty(this.time_type)
                len = 0;
            else
                switch this.time_type
                    case 0 % I'm in MAT TIME
                        len = numel(this.mat_time);
                    case 1 % I'm in UNIX TIME
                        len = numel(this.unix_time);
                    case 2 % I'm in REF TIME
                        len = numel(this.time_diff);
                end
            end
        end
        
        function n_element = length(this)
            % Get the total number of element stored in the object
            %
            % SYNTAX
            %   n_element = length(this)
            if isempty(this.time_type)
                n_element = 0;
            else
                switch this.time_type
                    case 0 % I'm in MAT TIME
                        n_element = length(this.mat_time);
                    case 1 % I'm in UNIX TIME
                        n_element = length(this.unix_time);
                    case 2 % I'm in REF TIME
                        n_element = length(this.time_diff);
                end
            end
        end
        
        function n_element = getLen(this)
            % Get the total number of element stored in the object
            %
            % SYNTAX
            %   n_element = getLen(this)
            n_element = this.length();
        end
        
        function [n_epochs] = getExpectedLen(this)
            % get the number of epochs (with constant rate) that the object should contain
            %
            % SYNTAX
            %   [n_epochs] = getExpectedLen(this)
            n_epochs = round((this.last.getMatlabTime() - this.first.getMatlabTime()) * (86400 / this.getRate())) + 1;
        end
        
        function [len_sec] = getSecLen(this)
            %get the legnth of time in second
            %
            % SYNTAX
            %   [len_sec] = this.getSecLen()
            len_sec = this.last - this.first;
        end
        
        function [empty]  = isempty(this)
            % return the status of emptyness of the object
            %
            % SYNTAX
            %   [empty]  = isempty(this)
            switch this.time_type
                case 0 % I'm in MAT TIME
                    empty = isempty(this.mat_time);
                case 1 % I'm in UNIX TIME
                    empty = isempty(this.unix_time);
                case 2 % I'm in REF TIME
                    empty = isempty(this.time_diff);
            end
        end
        
        function [empty]  = isEmpty(this)
            % return the status of emptyness of the object
            %
            % SYNTAX
            %   [empty]  = isempty(this)
            empty = this.isempty();
        end
        
        function [nan_list] = isnan(this)
            % return the logical NaN of the object
            %
            % SYNTAX
            %   [nan_list] = isnan(this)
            switch this.time_type
                case 0 % I'm in MAT TIME
                    nan_list = isnan(this.mat_time);
                case 1 % I'm in UNIX TIME
                    nan_list = isnan(this.unix_time);
                case 2 % I'm in REF TIME
                    nan_list = isnan(this.time_diff);
            end
        end
        
        function [rate] = getRate(this)
            % get observation rate approximated at 3 digits
            %
            % SYNTAX
            %   [rate]  = getRate(this)
            if (this.length() == 1)
                rate = 1;
            else
                switch this.time_type
                    case 0 % I'm already in MAT TIME
                        rate = round(median(diff(this.mat_time*86400)) * 1e3) / 1e3;
                    case 1 % I'm in UNIX TIME
                        % constants in matlab are slower than copied values :-( switching to values
                        % this.mat_time = double(this.unix_time) / this.SEC_IN_DAY + this.UNIX_ZERO + this.unix_time_f;
                        tmp_time = double(this.unix_time) + this.unix_time_f;
                        rate = round(median(diff(tmp_time)) * 1e3) / 1e3;
                    case 2 % I'm in REF TIME
                        rate = round(median(diff(this.time_diff)) * 1e3) / 1e3;
                end
            end
        end
        
        function [nominal_time, nominal_time_ext] = getNominalTime(this, rate, is_ext)
            % get the nominal time aka rounded time cosidering a constant
            % sampling rate
            %
            % OUTPUT
            %   nominal_time        it's the rounded time around rate steps
            %   nominal_time_ext    it's the rounded time with no gaps or duplicates
            %
            % SYNTAX
            %   [nominal_time, nominal_time_ext] = this.getNominalTime(<rate>)
            %   nominal_time                     = this.getNominalTime(<rate>, false (default))
            %   nominal_time_ext                 = this.getNominalTime(<rate>, true)
            if nargin < 2 || isempty(rate)
                rate = this.getRate();
            end
            if nargin < 3 || isempty(is_ext)
                is_ext = false;
            end
            
            nominal_time_zero = round(this.first.getMatlabTime()); % round at the closest time
            rinex_time = this.getRefTime(nominal_time_zero);
            nominal_time = round(rinex_time / rate) * rate;
                
            if nargout == 2 || is_ext
                ref_time = (nominal_time(1) : rate : nominal_time(end))';
                
                % reordering observations filling empty epochs with zeros;
                nominal_time_ext = GPS_Time(nominal_time_zero, ref_time, this.isGPS(), 2);
                nominal_time_ext.toUnixTime;
                if is_ext && nargout < 2
                    nominal_time = nominal_time_ext;
                else
                    nominal_time = GPS_Time(nominal_time_zero, nominal_time, this.isGPS(), 2);
                    nominal_time.toUnixTime;
                end
            else
                nominal_time = GPS_Time(nominal_time_zero, nominal_time, this.isGPS(), 2);
                nominal_time.toUnixTime;
            end
        end
        
        function [rounded_time] = getRoundedTime(this, rate)
            % get the rounded time aka rounded time cosidering a constant
            % sampling rate
            % w.r.t. nominal time, rounded time is fixed at the center of the session, nominal at the border
            %
            % OUTPUT
            %   rounded_time        it's the rounded time in the middle of rate steps
            %
            % SYNTAX
            %   [rounded_time] = this.getRoundedTime(<rate>)
            
            rounded_time = this.getCopy;
            rounded_time = rounded_time.addIntSeconds(rate/2);
            rounded_time = rounded_time.getNominalTime(rate);
            rounded_time = rounded_time.addIntSeconds(-rate/2);
        end
        
        function [sync_time, id_sync] = getSyncedTime(time_list, rate)
            % Get the common time among all the times
            %
            % OUTPUT
            %   sync_time   GPS_time of the continuous time containing all the times
            %   id_sync     each column will contains the ids of the positions of the times in sync_time
            %
            % SYNTAX
            %   [sync_time, id_sync] = time_list.getSyncedTime(rate);
            %
            % EXAMPLE:
            %   [sync_time, id_sync] = time_list.getSyncedTime(30);

            n_time = size(time_list(:),1);
            if nargin < 2 || isempty(rate)
                rate = 1e-6;

                for i = 1 : n_time
                    if (time_list(i).length) > 2
                        rate = lcm(round(rate * 1e6), round(time_list(i).getRate * 1e6)) * 1e-6;
                    end
                end
            end

            % prepare reference time
            % processing time will start with the receiver with the last first epoch
            %          and it will stop  with the receiver with the first last epoch
            time_ok = false(n_time, 1);
            for i = 1 : n_time
                time_ok(i) = not(time_list(i).isEmpty);
            end
            if not(any(time_ok))
                sync_time = GPS_Time();
                id_sync = [];
            else
                time_zero = round(time_list(find(time_ok, 1, 'first')).first.getMatlabTime() * 24)/24; % get the reference time at the beginning of one day
                
                % Get all the common epochs
                t = [];
                for i = 1 : n_time
                    rec_rate = min(5, time_list(i).getRate);
                    t = [t; round(time_list(i).getRefTime(time_zero) / rec_rate) * rec_rate];
                end
                t = unique(t);
                
                % If rate is specified use it
                if nargin > 1
                    t = intersect(t, (t(1) : rate : t(end) + rate)');
                end
                
                % Create reference time
                sync_time = GPS_Time(time_zero, t);
                id_sync = nan(sync_time.length(), n_time);
                
                % Get intersected times
                for i = 1 : n_time
                    if  not(time_list(i).isEmpty)
                        rec_rate = min(5, time_list(i).getRate);
                        [~, id1, id2] = intersect(t, round(time_list(i).getRefTime(time_zero) / rec_rate) * rec_rate);
                        id_sync(id1, i) = id2;
                    end
                end
            end
        end

        
        function [mat_time] = getMatlabTime(this)
            % get Matlab Time, precision up to the 0.1 milliseconds precision
            %
            % SYNTAX
            %   [mat_time] = getMatlabTime(this)
            mat_time = [];
            for t = 1 : size(this(:),1)
                switch this(t).time_type
                    case 0 % I'm already in MAT TIME
                        mat_time_tmp = this(t).mat_time;
                    case 1 % I'm in UNIX TIME
                        % constants in matlab are slower than copied values :-( switching to values
                        % this.mat_time = double(this.unix_time) / this.SEC_IN_DAY + this.UNIX_ZERO + this.unix_time_f;
                        mat_time_tmp = ((double(this(t).unix_time) + this(t).unix_time_f) / 86400 + 719529);
                    case 2 % I'm in REF TIME
                        mat_time_tmp = this(t).time_ref + this(t).time_diff / 86400;
                end
                mat_time = [mat_time; mat_time_tmp]; %#ok<AGROW>
            end
        end
        
        function [unix_time, unix_time_f, second_correction] = getUnixTime(this)
            % get Unix Time, precision up to the ps precision
            second_correction = 0;
            %
            % SYNTAX
            %   [unix_time, unix_time_f, second_correction] = getUnixTime(this)
            switch this.time_type
                case 0 % I'm in MAT TIME
                    % constants in matlab are slower than copied values :-( switching to values
                    % time_s = (this.mat_time - this.UNIX_ZERO) * this.SEC_IN_DAY; % convert mat_time in seconds
                    % due to numerical error propagation I can keep only 4 decimal
                    time_s =  (this.mat_time - 719529) * 86400; % convert mat_time in seconds
                    unix_time = uint32(fix(round(time_s * 1e4) / 1e4));
                    unix_time_f = round((time_s - double(unix_time)) * 1e4) / 1e4;
                    second_correction = - floor(unix_time_f);
                    unix_time = unix_time - uint32(second_correction);
                    unix_time_f = unix_time_f + second_correction;
                case 1 % I'm already in UNIX TIME
                    unix_time = this.unix_time;
                    unix_time_f = this.unix_time_f;
                case 2 % I'm in REF TIME
                    % constants in matlab are slower than copied values :-( switching to values
                    % time_s = (this.mat_time - this.UNIX_ZERO) * this.SEC_IN_DAY; % convert mat_time in seconds
                    time_s = (this.time_ref - 719529) * 86400;
                    unix_time = uint32(fix(round((time_s + this.time_diff) * 1e4) / 1e4));
                    rounding = 2.^(round(47 - max(0,log2(time_s + eps(time_s))))); % 52 bits of mantissa -> but I need to consider only 47 bits to keep precision
                    unix_time_f = round((time_s - double(unix_time)) .* rounding) ./ rounding + this.time_diff;
                    second_correction = - floor(unix_time_f);
                    unix_time = unix_time - uint32(second_correction);
                    unix_time_f = unix_time_f + second_correction;
            end
        end
        
        function date6col = get6ColDate(this)
            % get time, 6 column format
            %
            % SYNTAX
            %   date6col = get6ColDate(this)
            time_base = this.getCopy; 
            time_base.toUnixTime; % to be safe
            time_base.unix_time_f = zeros(size(time_base.unix_time_f)); % removing fractional part
            date6col = datevec(time_base.getMatlabTime);
            date6col(:,6) = floor(date6col(:,6));
            tmp = GPS_Time(date6col);
            tmp.toUnixTime; % to be safe
            fractional_part = round(tmp - this, 10);
            date6col(:,6) = date6col(:,6) - fractional_part ;
        end
        
        function yy = getYY(this)
            [yy, ~, ~] = getDOY(this);
            yy = yy - floor(yy/1000)*1000;
        end
        
        function changeRef(this, new_time_mat_ref)
            % change the reference time in use by the object to store the data
            %
            % SYNTAX
            %   changeRef(this, new_time_mat_ref)
            
            this.toRefTime(); % the object should store data into ref_time data type
            this.time_diff = this.time_diff + (this.time_ref - new_time_mat_ref) * 86400;
            this.time_ref = new_time_mat_ref;
        end
        
        function [time_diff, time_ref] = getRefTime(this, new_time_mat_ref)
            % get Reference Time, precision up to the ps precision
            %
            % INPUT:
            %   new_time_mat_ref: reference time in matlab time (double)
            % SYNTAX
            %   [time_diff, time_ref] = this.getRefTime(new_time_mat_ref)
            
            if this.length == 0
                time_diff = [];
                time_ref = [];
            else
                switch this.time_type
                    case 0 % I'm in MAT TIME
                        time_ref = fix(this.mat_time(1));
                        % due to numerical error propagation I can keep only 4 decimal digits
                        time_diff = (this.mat_time - time_ref) * 86400;
                        if (nargin == 2)
                            % optional change of reference
                            time_diff = time_diff + (time_ref - new_time_mat_ref) * 86400;
                            time_ref = new_time_mat_ref;
                        end
                    case 1 % I'm in UNIX TIME
                        % constants in matlab are slower than copied values :-( switching to values
                        % this.UNIX_ZERO == 719529;
                        if nargin == 2
                            time_ref = fix((new_time_mat_ref(1)  - 719529.0) * 86400);
                            rounding = 10.^(round(16 - max(0,log10(ceil(new_time_mat_ref(1)) * 86400 + eps(new_time_mat_ref(1) * 86400))))); % 52 bits of mantissa
                            time_ref_f = round(rem((new_time_mat_ref(1)  - 719529.0) * 86400, 1) * rounding) / rounding;
                        else
                            time_ref = this.unix_time(1);
                            time_ref_f = 0;
                        end
                        time_diff = double(int64(this.unix_time) - int64(time_ref)) + this.unix_time_f - time_ref_f;
                        time_ref = (double(time_ref) / 86400 + 719529.0) + time_ref_f / 86400;
                    case 2 % I'm in REF TIME
                        if (nargin == 2)
                            % optional change of reference
                            time_diff = this.time_diff + (this.time_ref - new_time_mat_ref) * 86400;
                            time_ref = new_time_mat_ref;
                        else
                            time_ref = this.time_ref;
                            time_diff = this.time_diff;
                        end
                end
            end
        end
        
        function [gps_week, gps_sow, gps_dow] = getGpsWeek(this,id)
            % get Reference Time, precision up to the ps precision
            %
            % SYNTAX
            %   [gps_week, gps_sow, gps_dow] = this.getGpsWeek()
            if this.isUTC
                gps_time = this.getCopy();
                gps_time.toGps();
            else
                gps_time = this;
            end
            [unix_time, unix_time_f] = gps_time.getUnixTime(); %#ok<PROP>
            if nargin == 2
                unix_time = unix_time(id);
                unix_time_f = unix_time_f(id);
            end
            [gps_week, gps_sow, gps_dow] = gps_time.unixTimeToGps(unix_time, unix_time_f); %#ok<PROP>
        end
        
        function [second] = getSecond(this)
            % get second of the times,
            %
            % SYNTAX
            %   [second] = getSecond(this)
            
           [seconds, fraction_of_seconds] = this.getUnixTime();
            second = double(seconds - floor(seconds/60)*60) + fraction_of_seconds;
           
        end
        
        function [gps_time] = getGpsTime(this, gps_offset)
            % Get time as number of seconds from Jan 6, 1980
            %
            % SYNTAX
            %   [gps_time] = this.getGpsTime(gps_offset)
            [unix_time, unix_time_f] = this.getUnixTime(); %#ok<PROPLC>
            if nargin == 1
                % gps_time = double(unix_time -  GPS_Time.UNIX_GPS_SEC_DIFF) + unix_time_f;
                gps_time = double(unix_time - uint32(315964800)) + unix_time_f;  %#ok<PROPLC>
            else
                max_digits = 15-ceil(log10(gps_offset));
                gps_time = round((double(unix_time - uint32(315964800)) - gps_offset) * max_digits) / max_digits + unix_time_f; %#ok<PROPLC>
            end
        end
        
        function [mjd] = getMJD(this, id)
            % Get Modified julian date
            %
            % SYNTAX
            %   [mjd] = this.getMJD()
            if nargin == 2
                date = this.getEpoch(id).get6ColDate;
            else
                date = this.get6ColDate;
            end
            [~, mjd] = date2jd(date);
        end
        
        function [jd] = getJD(this, id)
            % Get julian date
            %
            % SYNTAX
            %   [jd] = this.getJD()
            if nargin == 2
                date = this.getEpoch(id).get6ColDate;
            else
                date = this.get6ColDate;
            end
            jd = date2jd(date);
        end
        
        function [jd_tdb] = getJDTDB(this)
            % Get TDB julian date
            %
            % SYNTAX
            %   [jd_tdb] = this.getJDTD()
            this.toUtc;
            [jd_utc] = this.getJD();
            
            corr = (32.184 + 19 - this.getLeapSeconds() ) / 86400.0;
            
            jd_tdt = jd_utc + corr;
            
            % time argument for correction
            
            t = (jd_tdt - 2451545.0) / 36525.0;
            
            % compute correction in microseconds
            
            corr = 1656.675  * sind(35999.3729 * t + 357.5287)...
                + 22.418     * sind(32964.467  * t + 246.199)...
                + 13.84      * sind(71998.746  * t + 355.057)...
                +  4.77      * sind( 3034.906  * t +  25.463)...
                +  4.677     * sind(34777.259  * t + 230.394)...
                + 10.216 * t .* sind(35999.373  * t + 243.451)...
                +  0.171 * t .* sind(71998.746  * t + 240.98 )...
                +  0.027 * t .* sind( 1222.114  * t + 194.661)...
                +  0.027 * t .* sind( 3034.906  * t + 336.061)...
                +  0.026 * t .* sind(  -20.186  * t +   9.382)...
                +  0.007 * t .* sind(29929.562  * t + 264.911)...
                +  0.006 * t .* sind(  150.678  * t +  59.775)...
                +  0.005 * t .* sind( 9037.513  * t + 256.025)...
                +  0.043 * t .* sind(35999.373  * t + 151.121);
            
            % convert corrections to days
            
            corr = 0.000001 * corr / 86400.0;
            
            % compute TDB julian date
            
            jd_tdb = jd_tdt + corr;
        end
        
        function [year, doy, sod] = getDOY(this)
            % get Reference Time, precision up to the ps precision
            %
            % SYNTAX
            %   [year, doy, sod] = getDOY(this)
            if this.isUTC
                time = this.getCopy();
                time.toGps();
            else
                time = this;
            end
            
            mat_time = time.getMatlabTime;
            [year, ~] = datevec(mat_time);
            % deal with loss of presition (keep 9 decimal digits)
            time = round((mat_time - datenummx(year,1,1))* 1e9) / 1e9;
            doy = floor(time) + 1; % days from the beginning of the year
            sod = ((time - doy +1) * 86400); % seconds from the beginning of the year
        end
        
        function [year, month, day, hour, minute, second] = getCalEpoch(this, idx)
            % get year month doy hour minute second
            %
            % SYNTAX
            %   [year, month, doy, hour, minute, second] = getCalEpoch(this,idx)
            if nargin == 1
                idx = ones(this.length(),1) > 0;
            end
            str_time = this.toString();
            year = str2num(str_time(idx,1:4));
            month = str2num(str_time(idx,6:7));
            day = str2num(str_time(idx,9:10));
            hour = str2num(str_time(idx,12:13));
            minute = str2num(str_time(idx,15:16));
            second = str2num(str_time(idx,18:27));
        end
        
        function date_string = toString(this, date_format)
            % Convert a date to string format
            % Date format support also decimals 
            %   e.g. date_format = 'HH:MM:SS.ssss'
            %
            % SYNTAX
            %   date_string = toString(this, date_format)
            if this.isempty()
                date_string = '';
            else
                if (nargin == 2)
                    date_format(date_format == 's') = 'A';
                    time = this.getMatlabTime();
                    time(isnan(time)) = 0;
                    if any(date_format == 'A')
                        date_string = datestr(floor(time*86400)/86400, date_format);
                    else
                        date_string = datestr(time, date_format);
                    end
                else
                    time = round(this.getMatlabTime() * 86400 * 1e7) / 1e7 / 86400;
                    time(isnan(time)) = 0;
                    [~, fraction_of_seconds] = this.getUnixTime();
                    fraction_of_seconds = round(fraction_of_seconds * 1e7) / 1e7;
                    date_6col = datevec(time - (mod(fraction_of_seconds, 1) / 86400));
                    date_6col(:,6) = round(date_6col(:,6)) + mod(fraction_of_seconds, 1);
                    date_string = reshape(sprintf('%04d/%02d/%02d %02d:%02d:%010.7f', date_6col')',27,numel(time))';
                end
                
                if (nargin == 2) && any(date_format == 'A') && (size(date_string,1) > 0)
                    % I have a fractional par
                    [~, fraction_of_seconds] = this.getUnixTime();
                    fraction_of_seconds = round(fraction_of_seconds * 1e7) / 1e7;
                    
                    id = find(date_string(1, :) == 'A');
                    date_string = date_string';
                    date_string(id,:) = reshape(sprintf(['%0' num2str(numel(id)) 'd'], round(mod(fraction_of_seconds, 1) * 10^(numel(id)))), numel(id), size(date_string,2));
                    date_string = date_string';
                end
                
                if (nargin == 1)
                    if this.isGPS()
                        date_string = [char(date_string(:,:)) char(repmat(' GPS',size(date_string,1),1))];
                    else
                        date_string = [char(date_string(:,:)) char(repmat(' UTC',size(date_string,1),1))];
                    end
                elseif strfind(date_format,'TTT') %#ok<*STRIFCND>
                    if this.isGPS()
                        date_string = reshape(regexprep(serialize(date_string')', 'TTT','GPS'), size(date_string,2), size(date_string,1))';
                    else
                        date_string = reshape(regexprep(serialize(date_string')', 'TTT','UTC'), size(date_string,2), size(date_string,1))';
                    end
                end
            end
        end
        
        function date_string = toStringLocal(this)
            % Convert a date to string format
            % Date format support also decimals 
            %   e.g. date_format = 'HH:MM:SS.ssss'
            %
            % Append "local time (GMT+xx)"
            % where xx is the time zone offset in hours
            % SYNTAX
            %   date_string = toStringLocal(this, date_format)
            if nargin < 2
                date_format = 'yyyy-mm-dd HH:MM:SS';
            end
                
            time = this.getCopy;
            time.addSeconds(-GPS_Time.getLocalTimeOffset * 3600);            
            date_string = sprintf('%s local time (GMT%-2d)', time.toString(date_format), GPS_Time.getLocalTimeOffset);            
        end
        
        function sinex_str = toSinexStrDate(this)
            % Convert a date to a sinex format (yy:doy:sod)
            %
            % SYNTAX
            %   sinex_str = toSinexStrDate(this)
            [year , doy, sod] = this.getDOY();
            yy = year;
            yy(year>= 2000) = year(year>= 2000) - 2000;
            yy(year< 2000)  = year(year< 2000)  - 1900;
            n_ep = length(year);
            sinex_str = reshape(sprintf('%2d:%03d:%05d',[yy,doy,round(sod)]'),12,n_ep)';
        end
        
        function date_string = toStringGpsWeek(this)
            % Convert a date to string format
            %
            % SYNTAX
            %   date_string = toStringGpsWeek(this)
            if this.isempty()
                date_string = '';
            else
                [w, s, d] = this.getGpsWeek();
                date_string = sprintf('Week %d - dow %d - sow %d\n', w, d, s);
            end
        end
        
        function this = round(this, rounding)
            % round the time
            % 
            % INPUT
            %   rounding [seconds]
            %
            % SYNTAX 
            %   this = this.round(rounding);
            %
            % EXAMPLE:
            %   this = this.round(1e-5);
            switch this.time_type
                case 0 % I'm in MAT TIME
                    this.mat_time = (round(this.mat_time * 86400 ./ rounding) .* rounding) / 86400;
                case 1 % I'm in UNIX TIME
                    this.unix_time_f = round(this.unix_time_f ./ rounding) .* rounding;
                    idx =  this.unix_time_f >= 1;
                    this.unix_time(idx) = this.unix_time(idx) + uint32(ceil(this.unix_time_f(idx)));
                    this.unix_time_f(idx) = this.unix_time_f(idx) - ceil(this.unix_time_f(idx));
                    
                    idx =  this.unix_time_f < 0;
                    this.unix_time(idx) = this.unix_time(idx) - uint32(-floor(this.unix_time_f(idx)));
                    this.unix_time_f(idx) = this.unix_time_f(idx) - floor(this.unix_time_f(idx));
                case 2 % I'm in REF TIME
                    this.time_diff = round(this.time_diff ./ rounding) .* rounding;
            end
        end
        
        function new_obj = getEpoch(this, id)
            % Overloading of the operator index (getEpoch)
            % get a copy of the obj containing only the selected epoch id of time
            %
            % SYNTAX
            %   this.getEpoch(id)
                      
            try
                switch this.time_type
                    case 0 % I'm in MAT TIME
                        new_obj = GPS_Time(this.mat_time(id), [], this.is_gps);
                    case 1 % I'm in UNIX TIME
                        new_obj = GPS_Time(uint32(this.unix_time(id)), this.unix_time_f(id), this.is_gps);
                    case 2 % I'm in REF TIME
                        new_obj = GPS_Time(this.time_ref, this.time_diff(id), this.is_gps);
                        new_obj.time_type = 2; % if is empty GPS_Time cannot recognize the input
                end
            catch
                % this is faster than checking if id == 0 or id > this.length() (very limit case)
                % edit of the 7th of October 2019
                new_obj = GPS_Time();
                new_obj.time_type = this.time_type;
            end
        end
        
        function [time_head, id_ok] = head(gps_list, n_seconds)
            % Get time head
            %
            % SYNTAX
            %   [time_head, id_ok] = this.head(n_seconds)
            n_time = size(gps_list(:),1);
            time_head(n_time) = GPS_Time;
            for t = 1 : n_time
                time_lim = gps_list(t).first.getCopy;
                rate = gps_list(t).getRate;
                time_lim.addIntSeconds(round(n_seconds / rate) * rate + rate/2);
                id_ok = gps_list(t) <= time_lim;
                time_head(t) = gps_list(t).getEpoch(id_ok);
            end
        end
        
        function [time_tail, id_ok] = tail(gps_list, n_seconds)
            % Get time tail
            %
            % SYNTAX
            %   [time_tail, id_ok] = this.tail(n_seconds)
            n_time = size(gps_list(:),1);
            time_tail(n_time) = GPS_Time;
            for t = 1 : n_time
                time_lim = gps_list(t).last.getCopy;
                rate = gps_list(t).getRate;
                time_lim.addIntSeconds(-round(n_seconds / rate) * rate + rate/2);
                id_ok = gps_list(t) >= time_lim;
                time_tail(t) = gps_list(t).getEpoch(id_ok);
            end
        end
        
        function setEpoch(this, id, gps_time)
            % Overloading of the operator index (getEpoch)
            % get a copy of the obj containing only the selected epoch id of time
            %
            % SYNTAX
            %   this.getEpoch(id)
            
            if islogical(id)
                max_id = find(id == true, 1, 'last');
            else
                max_id = max(id);
            end
            
            if max_id < this.length()
      
                switch this.time_type
                    case 0 % I'm in MAT TIME
                        gps_time.toMatlabTime();
                        this.mat_time(id) = gps_time.mat_time;
                    case 1 % I'm in UNIX TIME
                        gps_time.toUnixTime();
                        this.unix_time(id) = gps_time.unix_time;
                        this.unix_time_f(id) = gps_time.unix_time_f;
                    case 2 % I'm in REF TIME
                        gps_time = gps_time.getRefTime(this.ref_time);
                        this.time_diff(id) = gps_time.time_diff;
                        
                end
            end
        end
        
        function time = getCentralTime(this)
            % return the central epoch time stored in the a receiver
            %
            % OUTPUT
            %   time     GPS_Time
            %
            % SYNTAX
            %   xyz = this.getCentralTime()
            id = round(this.length()/2);
            time = this.getEpoch(id);
        end
        
        function remEpoch(this, id)
            % DESCRIPTION: remove epochs by index
            %
            % SYNTAX
            %   this.remEpoch(id)
            
            if islogical(id)
                max_id = find(id == true, 1, 'last');
            else
                max_id = max(id);
            end
            
            switch this.time_type
                case 0 % I'm in MAT TIME
                    if (length(this.mat_time) >= max_id)
                        this.mat_time(id) = [];
                    end
                case 1 % I'm in UNIX TIME
                    if (length(this.unix_time) >= max_id)
                        this.unix_time(id) = [];
                        this.unix_time_f(id) = [];
                    end
                case 2 % I'm in REF TIME
                    if (length(this.time_diff) >= max_id)
                        this.time_diff(id) = [];
                    end
            end
        end

        function new_obj = first(this, id_subset)
            % Get first element stored in GPS_Time
            %
            % SYNTAX
            %   new_obj = first(this, id_subset)
            if (nargin == 1)
                new_obj = this.getEpoch(1);
            else
                if islogical(id_subset)
                    new_obj = this.getEpoch(find(id_subset, 1, 'first'));
                else
                    new_obj = this.getEpoch(id_subset(1));
                end
            end
        end
        
        function new_obj = last(this, id_subset)
            % Get last element stored in GPS_Time
            %
            % SYNTAX
            %   new_obj = last(this, id_subset)
            if (nargin == 1)
                new_obj = this.getEpoch(this.length());
            else
                if islogical(id_subset)
                    new_obj = this.getEpoch(find(id_subset(1 : this.length()), 1, 'last'));
                else
                    id_subset = id_subset(id_subset < this.length());
                    new_obj = this.getEpoch(id_subset(end));
                end
            end
        end
        
        function min_time = minimum(this,id_subset)
            % Get the minimum element stored in gps_time
            %
            % SYNTAX
            %   new_obj = last(this, id_subset)
            if (nargin == 1)
                new_obj = this.getCopy;
            else
                if islogical(id_subset)
                    new_obj = this.getEpoch(find(id_subset(1 : this.length())));
                else
                    id_subset = id_subset(id_subset < this.length());
                    new_obj = this.getEpoch(id_subset);
                end
            end
            time_mat = new_obj.getMatlabTime();
            [~,idx] = min(time_mat);
            min_time = new_obj.getEpoch(idx);
            
        end
        
        function max_time = maximum(this,id_subset)
            % Get the minimum element stored in gps_time
            %
            % SYNTAX
            %   new_obj = last(this, id_subset)
            if (nargin == 1)
                new_obj = this.getEpoch(1:this.length());
            else
                if islogical(id_subset)
                    new_obj = this.getEpoch(find(id_subset(1 : this.length())));
                else
                    id_subset = id_subset(id_subset < this.length());
                    new_obj = this.getEpoch(id_subset);
                end
            end
            time_mat = new_obj.getMatlabTime();
            [~,idx] = max(time_mat);
            max_time = new_obj.getEpoch(idx);
            
        end
        
        function gps_time_subset = getSubSet(this, index)
            % create a copy of the object having only a subset of time_diff
            %
            % SYNTAX
            %   gps_time_subset = getSubSet(this, index)
            gps_time_subset = this.getCopy();
            switch  this.time_type
                case 0
                    gps_time_subset.mat_time = gps_time_subset.mat_time(index);
                case 1
                    gps_time_subset.unix_time = gps_time_subset.unix_time(index);
                    gps_time_subset.unix_time_f = gps_time_subset.unix_time_f(index);
                case 2
                    gps_time_subset.unix_time = gps_time_subset.unix_time(index);
            end
        end
        
        function prec = getPrecision(this)
            % get precison of current time
            %
            % SYNTAX
            %   prec = getPrecision(this)
            switch this.time_type
                case 0 % I'm in MAT TIME
                    prec = eps(this.mat_time);
                case 1 % I'm in UNIX TIME
                    prec = eps(this.unix_time_f);
                case 2 % I'm in REF TIME
                    prec = 0;
            end
        end
    end
    
    % =========================================================================
    %    SETTERS
    % =========================================================================
    
    methods
        function setGPS(this, is_gps)
            % Set the memorization type
            %
            % SYNTAX
            %   this.setGPS(is_gps)
            this.is_gps = is_gps;
        end

        function setDateFormat(this, date_format)
            % Change the default value for "date format"
            %
            % SYNTAX
            %   this.setDateFormat(date_format)
            this.date_format = date_format;
        end
        
        function delId(this, id)
            % Delete time with id = id
            %
            % SYNTAX
            %   this.delId(id)
            switch this.time_type
                case 0 % I'm in MAT TIME
                    this.mat_time(id) =  [];
                case 1 % I'm in UNIX TIME
                    this.unix_time(id) = [];
                    this.unix_time_f(id) = [];
                case 2 % I'm in REF TIME
                    this.time_diff(id) = [];
            end
        end
        
        function delLast(this)
            % Delete last element stored in GPS_Time
            %
            % SYNTAX
            %   this.delLast
            this.delId(this.length());
        end
        
        function empty(this)
            this = GPS_Time();
        end
        
        function [time, idx1, idx2] = injectBatch(this, time_in)
            % inject a number of time , deleted overlapping
            idx1 = find(this.getNominalTime(min(this.getRate, 1)) >= time_in.getNominalTime(min(time_in.getRate, 1)).first, 1, 'first'); % first to erase
            if isempty(idx1)
                idx1 = this.length + 1;
            end
            idx2 = find(this.getNominalTime(min(this.getRate, 1)) <= time_in.getNominalTime(min(time_in.getRate, 1)).last, 1, 'last'); % last to erase 
            if isempty(idx2)
                idx2 = 0;
            end
            time = this.getEpoch(1 : (idx1 - 1));
            time.append(time_in);
            time.append(this.getEpoch((idx2 + 1) : this.length));
        end
    end
    
    % =========================================================================
    %    OPERATIONS
    % =========================================================================
    
    methods (Access = 'public')
        function this = addIntSeconds(this, n_seconds)
            % Add an integer number of seconds to all the times
            %
            % SYNTAX
            %   this = addIntSeconds(this, n_seconds)
            switch this.time_type
                case 0 % I'm in MAT TIME
                    this.mat_time = this.mat_time + n_seconds / 86400;
                case 1 % I'm in UNIX TIME
                    this.unix_time = uint32(int64(this.unix_time) + int64(n_seconds));
                case 2 % I'm in REF TIME
                    this.time_diff = this.time_diff + n_seconds;
            end
        end
        
        function this = addSeconds(this, n_seconds)
            % Add a floating point number of seconds to all the times
            %
            % SYNTAX
            %   this = addSeconds(this, n_seconds)
            switch this.time_type
                case 0 % I'm in MAT TIME
                    this.mat_time = this.mat_time + n_seconds(:) / 86400;
                case 1 % I'm in UNIX TIME
                    this.unix_time = uint32(int64(this.unix_time)  + int64(fix(n_seconds(:))));
                    this.unix_time_f = this.unix_time_f + rem(n_seconds(:),1);
                    this.unix_time = uint32(int64(this.unix_time) + int64(floor(this.unix_time_f)));
                    this.unix_time_f = this.unix_time_f - floor(this.unix_time_f);
                case 2 % I'm in REF TIME
                    this.time_diff = this.time_diff + n_seconds(:);
            end
        end
                        
        function res = lt(gt_1, gt_2)
            %%% DESCRIPTION: overload of '<' function
            %
            % SYNTAX
            %   res = lt(gt_1, gt_2)
            [unix_time1, unix_time_f1] = gt_1.getUnixTime();
            [unix_time2, unix_time_f2] = gt_2.getUnixTime();
            
            res = (unix_time1 < unix_time2) | ((unix_time1 == unix_time2)  & (unix_time_f1 < unix_time_f2)) ;
        end
        
        function res = gt(gt_1, gt_2)
            %%% DESCRIPTION: overload of '>' function
            %
            % SYNTAX
            %   res = gt(gt_1, gt_2)
            [unix_time1, unix_time_f1] = gt_1.getUnixTime();
            [unix_time2, unix_time_f2] = gt_2.getUnixTime();
            
            res = (unix_time1 > unix_time2) |( (unix_time1 == unix_time2) & (unix_time_f1 > unix_time_f2) );
        end
        
        function res = le(gt_1, gt_2)
            %%% DESCRIPTION: overload of '<=' function
            %
            % SYNTAX
            %   res = le(gt_1, gt_2)
            res = gt_1 < gt_2 | gt_1 == gt_2;
        end
        
        function res = ge(gt_1, gt_2)
            %%% DESCRIPTION: overload of '>=' function
            %
            % SYNTAX
            %   res = ge(gt_1, gt_2)
            res = gt_1 > gt_2 | gt_1 == gt_2;
        end        
        
        function res = eq(gt_1, gt_2)
            %%% DESCRIPTION: check if two time are equals up to precision
            %
            % SYNTAX
            %   res = eq(gt_1, gt_2)
            [~, sec, sec_f] = gt_1.minus(gt_2);
            prec = max(gt_1.getPrecision, gt_2.getPrecision);
            res = abs(double(sec) + sec_f) < prec;
        end
        
        function [sec, sec_i, sec_f] = minus(gt_1, gt_2)
            % OUTPUT:
            %    sec = difference in seconds
            %    sec = unit part
            %    sec_f = fractional difference in seconds
            % DESCRIPTION: overload of '-' function
            %
            % SYNTAX
            %   [sec, sec_i, sec_f] = minus(gt_1, gt_2)
            %
            %%% get unix time
            [unix_time1, unix_time_f1] = gt_1.getUnixTime();
            [unix_time2, unix_time_f2] = gt_2.getUnixTime();
            sec_i = int64(unix_time1) - int64(unix_time2);
            sec_f = unix_time_f1 - unix_time_f2;
            
            % make the two values consistent
            idx_sec = sec_i > 0;
            idx_sec_f = sec_f >0;
            idx_conflict = xor(idx_sec,idx_sec_f);
            if sum(idx_conflict) > 0
                sec_i(idx_conflict) = sec_i(idx_conflict) + int64(sign(sec_f(idx_conflict)));
                sec_f(idx_conflict) = sec_f(idx_conflict) - sign(sec_f(idx_conflict));
            end
            sec = double(sec_i) + sec_f;
            
        end 
        
        function [gps_time_min] = min(gps_time_one, gps_time_two)
            % get the minimux of two gps time
            % SYNTAX:
            %     [gps_time_min] = min(gps_time_one, gps_time_two)
            diff = gps_time_two.first - gps_time_one.first;
            if diff < 0
                gps_time_min = gps_time_two.first;
            else
                gps_time_min = gps_time_one.first;
            end
        end
        
        function [gps_time_max] = max(gps_time_one, gps_time_two)
            % get the maximum of two gps time
            % SYNTAX:
            %     [gps_time_min] = min(gps_time_one, gps_time_two)
            diff = gps_time_two.first - gps_time_one.first;
            if diff > 0
                gps_time_max = gps_time_two.first;
            else
                gps_time_max = gps_time_one.first;
            end
        end
    end
    
    % =========================================================================
    %    STATIC CONSTRUCTOR
    % =========================================================================
    methods (Static, Access = 'public')
        function this = now()
            % construct GPS_Time from current time
            %
            % SYNTAX
            %   this = GPS_Time.now()
            mat_time = now();
            mat_time = mat_time + java.util.Date().getTimezoneOffset/(60*24);
            this = GPS_Time(mat_time, true);
        end
        
        function str = toInfo(time)
            % Show all the time info of the first epoch of time
            %
            % INPUT
            %   time    time can be a GPS_Time or a string or a matlab time
            %           < default value = now >
            %
            % SYNTAX
            %   str = GPS_Time.toInfo(<time>)
            %
            % EXAMPLE 
            %   str = GPS_Time.toInfo('2020/01/01 00:00');
            %   str = GPS_Time.toInfo(); 
            
            if nargin == 0
                time = GPS_Time.now;
            end
            if ~isa(time, 'GPS_Time')
                time = GPS_Time(time);
            end                
            time = time.first; 
            str = time.toString;
            [year, doy, sod] = time.getDOY;
            [gps_week, gps_sow, gps_dow] = time.getGpsWeek();
            
            str = sprintf('-----------------------\n GPS Time:\n %s\n %s\n\n YEAR DOY SOD\n %4d %3d %6.3f\n\n WEEK DOW SOW\n %4d %03d %6.3f\n-----------------------\n', ...
                str(1:10), str(12:end), ...
                year, doy, sod, ...
                gps_week, gps_dow, gps_sow);
       end
            
        function time_zone = getLocalTimeOffset()
            % get local time zone offset (in hours)
            %
            % SYNTAX
            %   time_zone = getLocalTimeOffset()
            time_zone = java.util.Date().getTimezoneOffset / 60;
        end
                
        function this = fromString(str_gps_time, is_gps)
            % construct gpstime from time as string
            % date separated by spaces yyyy mm dd HH MM SS.SSSSS
            %
            % SYNTAX
            %  this = GPS_Time.fromString(gps_time)
            if nargin == 1
                is_gps = true;
            end
            if isempty(str_gps_time)
                this = GPS_Time();
            else
                this = GPS_Time(str_gps_time, [], is_gps);
            end
        end
        
        function this = fromWeekDow(week, dow)
            % construct gps time from week and day of week  
            % WARNING: dow spans [0-6] like most IGS data
            % repository
            %
            % SYNTAX
            %   this = GPS_Time.fromWeekDow(week, dow)
            this = GPS_Time(week, dow, true, 3);
        end
        
        function this = fromGpsTime(gps_time)
            % construct gpstime from gps time (in seconds)
            %
            % SYNTAX
            %  this = GPS_Time.fromGpsTime(gps_time)
            this = GPS_Time(GPS_Time.GPS_ZERO, gps_time, true, 2);
        end
        
        function this = fromUnixTime(unix_time)
            % construct gpstime from UNIX time (in seconds)
            %
            % SYNTAX
            %  this = GPS_Time.fromUnixTime(unix_time)
            this = GPS_Time();
            this.GPS_Time_unix(uint32(floor(unix_time)), unix_time - floor(unix_time), false);
        end
        
        function this = fromWeekSow(week, sow)
            % construct gpstime from week and second of week 
            %[date, ~, ~] = GPS_Time.gps2date(week, sow);
            %
            % SYNTAX
            %   this = GPS_Time.fromWeekSow(week, sow)
            this = GPS_Time.fromWeekDow(week, (sow) / 86400);
        end
        
        function this = fromDoySod(year, doy, sod)
            % construct from year doy ad second of day
            %
            % SYNTAX
            %   this = GPS_Time.fromDoySod(year, doy, sod)
            if nargin == 2
                sod = 0;
            end
            unix_s = uint32((datenummx(year , 1, doy)  - datenummx(1970,1,1))*86400) + uint32(floor(sod));
            unix_s_f = sod - floor(sod);
            this = GPS_Time(unix_s, unix_s_f);
        end
        
        function this = fromRefTime(time_matlab_reference, time_difference, is_gps)
            % construct from matlab reference time / time diff
            %
            % INPUT 
            %   time_matlab_reference   time in matlab format
            %   time_difference         second from the reference
            %   is_gps                  flag, is GPS or UTC time?
            %
            % SYNTAX
            %   this = GPS_Time.fromRefTime(time_matlab_reference, time_difference, is_gps)
            this = GPS_Time;
            if nargin < 3 || isempty(is_gps)
                is_gps = true;
            end
            this = this.GPS_Time_ref(time_matlab_reference, time_difference, is_gps);
        end
        
        function this = fromMJD(mjd)
            % construct from MJD vector
            %
            % SYNTAX
            %   this = GPS_Time.fromMJD(mjd_vector)
            jday = mjd+2400000.5;
            deltat = jday - 2444244.5;
            week = floor(deltat/7);
            sec_of_week = (deltat - week*7)*86400;
            tow = round(sec_of_week);
            v_datenum = tow/(3600*24) + 7*(week) + datenummx([1980,1,6,0,0,0]);
            this = GPS_Time(v_datenum);
        end
    end
    
    % =========================================================================
    %    STATIC UNIX TIME
    % =========================================================================
    
    methods (Static, Access = 'public')
        function [unix_time, unix_time_f] = matToUnixTime(mat_time)
            % Conversion From MATLAB (expressed in days) type to UNIX TIME (expressed in uint32 seconds)
            %
            % SYNTAX
            %   tfunction [unix_time, unix_time_f] = matToUnixTime(mat_time)
            time_s = round((mat_time - 719529) * 86400 * 1e4)/1e4; % convert mat_time in seconds
            
            if (nargout == 2)
                unix_time_f = rem(time_s,1);
            end
            unix_time = uint32(fix(time_s));
        end
        
        function [unix_time, unix_time_f] = dateStringToUnixTime(time_string)
            % Conversion From STRING type to UNIX TIME (expressed in uint32 seconds) max precision ~0.1 ms
            %
            % SYNTAX
            %   [unix_time, unix_time_f] = dateStringToUnixTime(time_string)
            [unix_time, unix_time_f] = GPS_Time.matToUnixTime(datenum(time_string));
        end
        
        function [unix_time, unix_time_f] = gpsToUnixTime(gps_week, gps_time)
            % Conversion (shift) from GPS time (January 6, 1980) to UNIX time (January 1, 1970)
            %
            % SYNTAX
            %   [unix_time, unix_time_f] = gpsToUnixTime(gps_week, gps_time)
            if (nargout == 2)
                unix_time_f = rem(gps_time,1);
            end
            % constants in matlab are slower than copied values :-( switching to values
            % unix_time = uint32(gps_time - 0.5) + GPS_Time.UNIX_GPS_SEC_DIFF + uint32(gps_week) * GPS_Time.SEC_IN_WEEK;
            unix_time = uint32(gps_time - 0.5) + 315964800 + uint32(gps_week) * 604800;
        end
    end
    
    % =========================================================================
    %    GPS TIME
    % =========================================================================
    
    
    methods (Static, Access = 'public')
        % Shift from UNIX time (January 1, 1970 - msec) to GPS time (January 6, 1980 - sec)
        function [gps_week, gps_sow, gps_dow] = unixTimeToGps(unix_time, unix_time_f)
            % Conversion (shift) from Unix Time (January 1, 1970) to GPS time (January 6, 1980)
            %
            % SYNTAX
            %   [gps_week, gps_sow, gps_dow] = unixTimeToGps(unix_time, unix_time_f)
            %
            % constants in matlab are slower than copied values :-( switching to values
            % gps_time = mod(double(unix_time -  GPS_Time.UNIX_GPS_SEC_DIFF, GPS_Time.SEC_IN_WEEK)) + unix_time_f;
            % gps_week = uint32(fix((unix_time - GPS_Time.UNIX_GPS_SEC_DIFF / GPS_Time.SEC_IN_WEEK));
            gps_sow = double(mod(unix_time - 315964800, 604800)) + unix_time_f;
            gps_week = uint32(fix(double(unix_time - 315964800) / 604800));
            gps_dow = uint32(fix(gps_sow / 86400));
        end
        
        function [gps_week, gps_sow, gps_dow] = date2gps(date_vec)
            % Conversion from calendar date to GPS time.
            % SYNTAX
            %   [gps_week, gps_sow, gps_dow] = date2gps(date);
            %
            % INPUT:
            %   date = date [year, month, day, hour, min, sec]
            %
            % OUTPUT:
            %   gps_week = GPS week
            %   gps_sow  = GPS seconds of week
            %   gps_dow  = GPS day of week
            gps_start_datenum = 723186; %This is datenum([1980,1,6,0,0,0])
            
            %number of days since the beginning of GPS time
            %deltat   = (datenum([date(:,1), date(:,2), date(:,3)]) - gps_start_datenum);
            % hack: datenummmx is faster cause it does not check argins
            deltat   = (datenummx(date_vec(:,1:3)) - gps_start_datenum);
            
            gps_week = floor(deltat/7);            %GPS week
            gps_dow  = floor(deltat - gps_week*7); %GPS day of week
            gps_sow  = (deltat - gps_week*7)*86400;
            gps_sow = gps_sow + date_vec(:,4)*3600 + date_vec(:,5)*60 + date_vec(:,6); %GPS seconds of week
        end
        
        function [date, doy, dow] = gps2date(gps_week, gps_sow)
            
            % SYNTAX
            %   [date, doy, dow] = gps2date(gps_week, gps_sow);
            %
            % INPUT:
            %   gps_week = GPS week
            %   gps_sow  = GPS seconds of week
            %
            % OUTPUT:
            %   date = date [year month day hour min sec]
            %   doy  = day of year
            %   dow  = day of week
            %
            % DESCRIPTION:
            %   Conversion from GPS time to calendar date and day of year (DOY).
            
            
            
            gps_start_datenum = 723186; %This is datenum([1980,1,6,0,0,0])
            
            gps_dow = fix(gps_sow/86400);                             %day of week
            date = datevec(gps_start_datenum + 7*gps_week + gps_dow); %calendar date up to days
            gps_sod = gps_sow - gps_dow*86400;                        %seconds of day
            date(:,4) = floor(gps_sod/3600);                          %hours
            date(:,5) = floor(gps_sod/60 - date(:,4)*60);             %minutes
            date(:,6) = gps_sod - date(:,4)*3600 - date(:,5)*60;      %seconds
            
            %day of year (DOY)
            if (nargout > 1)
                doy = date2doy(datenum(date));
                doy = floor(doy);
            end
            
            %day of week
            if (nargout > 2)
                dow = gps_dow;
            end
            
        end
        
        function gps_mean = getMeanTime(gps_time1, gps_time2)
            % Given two gps time with the same number of epochs, retun the
            % mean time between each epochs
            %
            % SYNTAX
            %    gps_mean = GPS_time.getCentralTime(gps_time1, gps_time2)
            gps_diff = gps_time2 - gps_time1;
            gps_mean = gps_time1.getCopy;
            gps_mean = gps_mean.addSeconds(gps_diff/2);
        end
    end
    
    % =========================================================================
    %    TESTS
    % =========================================================================
    
    methods (Static, Access = 'public')
        function test()
            % Testing function, tests some basic transformations
            %
            % SYNTAX
            %   test()
            log = Logger.getInstance(); % Handler to the log object
            
            log.addMessage('Testing Class Time - single value UTC');
            tic;
            t = GPS_Time(datenum('01-Jul-1994 00:00:00'), [], false);
            t.toGps();
            t.toUtc();
            t.toUnixTime();
            t.toMatlabTime()
            t.toRefTime();
            t.toMatlabTime()
            t.toUnixTime();
            t.toRefTime();
            t.toUnixTime();
            t.toMatlabTime();
            t_diff = abs(t.mat_time - datenum('01-Jul-1994 00:00:00')) * 86400;
            if t_diff < 1e-5
                log.addStatusOk('Passed: difference under threshold (0.01 ms)');
            else
                log.addWarning(sprintf('Difference greater than (0.01 ms): %e',t_diff));
            end
            toc
            
            log.addMessage('Testing Class Time - multiple consecutive values GPS');
            tic;
            mat_time = datenum('01-Jul-1994 00:00:00');
            mat_time = (mat_time(1)-1:1/86400:mat_time(1)+1)';
            t = GPS_Time(mat_time, [], true);
            t.toGps();
            t.toUtc();
            t.toUnixTime();
            t.toMatlabTime()
            t.toRefTime();
            t.toMatlabTime()
            t.toUnixTime();
            t.toRefTime();
            t.toUnixTime();
            t.toMatlabTime();
            t.toGps();
            t_diff = max(abs(t.mat_time - mat_time)) * 86400;
            if t_diff < 2e-5
                log.addStatusOk('Passed');
            else
                log.addWarning(sprintf('Difference greater than 0.2 ms: %e',t_diff));
            end
            toc
        end
        
        function doyt = doy2fdoytr(doy,year)
            % get first doy of trimester whose doy is in
            if GPS_Time.isleap(year)
                if doy < 92
                    doyt = 1;
                elseif doy < 183
                    doyt = 92;
                elseif doy < 275
                    doyt = 183;
                else
                    doyt = 275;
                end
            else
                if doy < 91
                    doyt = 1;
                elseif doy < 182
                    doyt = 91;
                elseif doy < 274
                    doyt = 182;
                else
                    doyt = 274;
                end
            end
        end
        
        function [leap] = isleap(year)
            % is the year leap
            if mod(year, 4) == 0
                leap = true;
                if mod(year, 100) == 0
                    leap = false;
                    if mod(year, 400)==0
                        leap = true;
                    end
                end
            else
                leap = false;
            end
        end

    end
    
end

